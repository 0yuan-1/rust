# 安装

- 官网：<https://www.rust-lang.org>
- 更新：```rustup update```
- 卸载：```rustup uninstall```
- rust 程序：
  - 程序后缀名：```rs```
  - 文件名规范：```hello_world.rs```

# 项目管理

- cargo：```cargo --version```
- 创建项目：```cargo new project_name```
- 构建项目：```cargo build```
  - 直接运行构建项目命令是 debug 版本，如果要 release 版本则需要添加```--release```
- 运行项目：```cargo run```
- 检查项目代码：```cargo check```

## Cargo.tomal

- cargo 项目的配置文件
- **在 Rust 中，一个包（项目）通常被称作 crate。如一个第三方的库，则称一个 crate**

```
# 用来配置包（项目）
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

# 包（项目）所使用的依赖
[dependencies]
```

# 通用编程概念

## 变量与可变性

- Rust 中，变量是默认不可变的，如果一个变量的值后续要进行变化，则需要添加 “mut” 关键字

### 变量与常量

- 常量（constant）：常量在绑定值后也是不可变的，但与不可变的变量还是有区别：
  - 不可以使用 **mut**
  - 声明常量使用 **const** 关键字，它的类型必须标注
  - 常量可以在任何作用域进行声明
  - 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命名规范： Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如：
  - MAX_POINTS: ```const MAX_POINTS: u32 = 100_000;```

### Shadowing(隐藏)

- Rust 中，可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量，当后面的代码使用该变量时，就会使用新的，而不是旧的
- Shadow 和把变量标记为 **mut** 是不一样的
  - 如果不使用 **let** 关键字，那么重新给非 **mut** 的变量赋值会导致编译时错误
  - 而使用 **let** 声明的同名新变量，也是不可变的
  - 使用 **let**声明的同名新变量，它的类型可以与之前不同

## 数据类型

- 一般情况下，编译器都可以自动的推导出变量的数据类型，但当有多个数据类型符合一个变量时，则必须手动的设置

### 标量类型

- 一个标量类型代表一个单个值
- Rust 有四个主要的标量类型：
  - 整数类型
    - 无符号整数类型，以**u**开头
    - 有符号整数类型，以**i**开头
    - 一共有 5 种类型。8,16,32,64,128, **arch**.
    - **arch**：分别是“isize”和“usize”，**size** 的具体位数是由程序运行时的计算机架构决定的
    - 整数字面值：除了 byte 类型外，所有的数值字面值都允许使用类型后缀，例如：**57u8**：57是数值，u8是类型
  - 浮点类型
    - **f32**: 单精度
    - **f64**：双精度
  - 布尔类型
    - **true** 和 **false**
  - 字符类型
    - 占用 4 字节大小
    - 默认是 Unicode 标量值，而不是 ASCII 标量值

### 复合类型

- 将多个值存放到一个类型里
- Rust 提供两种基础的复合类型：元组（Tuple）、数组
  - 元组：
    - 可以将多个类型的值放到一个类型里
    - 长度固定
    - 创建 Tuple: ```let tup: (i32, f64, u8) = (500, 6.4, 1);```
    - 获取 Tuple 的元素值：```let (x, y, z) = tup; // 使用模式匹配来解构 Tuple，从而获取到元素的值```
    - 访问 Tuple 的元素：```println!("{}, {}, {}", tup.0, tup.1, tup.2); // 使用点标记法来访问元素的值```
  - 数组：
    - 创建数组：```let ary = [1,2,3,4,5,6];```
    - 数组的类型：```let ary2:[i32; 3] = [1,2,3]; // 显式的声明数组类型[type; len]```
    - 一般用于初始化数组： ```let ary3 =[0;3]; // 相当于 int ary[3] = {0};```
    - 访问数组的元素跟其他语言一样，但数组越界的处理上，Rust 是不允许的，具体表现为：**编译会通过**，**运行时会报错**

## 函数

- 函数使用 **fn** 关键字
- 函数必须声明每个参数的类型
- 函数的返回值类型必须在函数定义时，在 ‘->’ 后面声明。**函数的返回值不能被命名**

## 控制流

### if

- 在 rust 中，if 的 condition 中不需要添加‘()’
- 在 rust 中，if 的 condition 必须是布尔值
- 在 rust 中，if-else 的返回值类型必须是一样

### 循环

- loop：死循环，直到 break 条件生效
  - 如果 break 后面有跟表达式，则该表达式的值就是这个 loop 的返回值
- while
  - 跟其他语言的 while 循环基本一样
- for
  - 一般是用于遍历集合

# Range

- 标准库提供的一个库，指定一个开始数字和结束数字， Range 可以生成它们之间的数字（[start_num .. end_num)）
- rev 方法可以反转 Range

# 所有权

- 为了解决内存安全的问题，不再借助 GC 来进行管理（Java），或由程序员显示分配和释放内存（C、C++）
- 内存将有一个所有权系统来进行管理，其中包含一组编译器在编译时检查的规则，而因为检查是在编译期进行的，所以不会在运行期产生任何的开销
- 所有权解决的问题：
  - 跟踪代码的哪些部分正在使用 heap 的哪些数据
  - 最小化 heap 上的重复数据量
  - 清理 heap 上未使用的数据以避免空间不足
  - 所以所有权存在的原因是为了管理 heap 数据

## 所有权的规则

1. 每个值都有一个变量，该变量是该值的所有者
2. 每个值同时只能一个所有者
3. 当所有者超出作用域（scope）时，该值将被删除

### Drop 函数

- 当一个变量指向堆内存时，该变量离开作用域，rust 会自动调用 drop 函数

### 变量和数据交互的方式：移动（Move）

- 在 Rust 中，如果一个变量是指向栈内存，那么当其作为等号右值时，其值会被复制（拷贝）；当变量是指向堆内存，那么当作为右值时，其值会被移动到左值，该变量会变成无效。

### 变量和数据交互的方式：克隆（Clone）

- Rust 设计规则：Rust 不会自动创建数据的深拷贝
- clone 方法是对数据进行深拷贝

### 栈内存上的数据：复制（Copy）

- 当一个类型实现了 **Copy** 这个 trait， 那么旧的变量在赋值后仍然可用
- Rust 中规定：当一个类型或该类型的一部分实现了 drop 这个函数，那么 copy 则不能被实现
- 内置 copy 函数的类型：
  - 所有整型
  - bool
  - char
  - 所有浮点类型
  - Tuple 中，如果所有字段都是 Copy 的，那么其就可以 copy，否则不行。
    - (i32, i32) - 可以
    - (i32, String) - 不可以

## 所有权与函数

- 函数传参会与赋值一样均发生 **移动** 或 **复制** 的情况

## 返回值与作用域

- 返回值会发生所有权的转移

### 变量的所有权

- 把一个值赋值给其他变量时， 会发生移动
- 当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 函数 清理，除非数据的所有权移动到另一个变量上

# 引用与借用

## 引用

- Rust 为了避免变量的所有权的改变，而需要多次倒腾变量，提出了“引用”的特性，允许引用某些值而不取得所有权
- 使用引用， “&” 关键字

## 借用

- 当把引用作为函数参数时， 这个行为叫做借用
- 不能修改借用的东西， 因为引用默认是不可变的

## 可变引用

- **&mut** 可以将一个引用标示为可变引用
- **限制：在同一个作用域内，对某块数据，有且仅有一个可变的引用**，这样做的好处是为了防止数据竞争
  - 发生数据竞争的三种行为：
    1. 两个说多个指针同时访问同一个数据
    2. 至少有一个指针用于写入数据
    3. 没有使用任何机制来同步对数据的访问
- 可以通过创建新的作用域，来允许非同时的创建多个可变引用
- **限制：不可以同时拥有一个可变引用和不可变引用**

## 悬空引用（Dangling References）

- **一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用**
- 在 Rust 中，编译器则确保了不会发生这种情况

## 引用的规则

- 在任何给定的时刻，只能满足下列条件之一：
  - 一个可变的引用
  - 任意数量不可变的引用
- **引用必须一直有效**

# 切片（slice）

- Rust 中另一种不持有所有权的数据类型

## 字符串切片

- 指向字符串中的一部分引用， 当该字符串无效时，其切片也随之无效 
- 形式： ```&str[start_index..end_index]```
  - **start_index**: 切片起始位置的索引
  - **end_index**: 切片终止位置的下一个索引值
- 语法糖
  - 如果 start_index 从 0 开始，则可以不写
  - 如果 end_index 是字符串的长度，也可以不写
- **注意**
  - 字符串切片的范围索引必须发生在有效的 UTF-8 字符边界内
  - 当尝试从一个多字节的字符中创建字符串切片，程序会报错并退出
- 字符串切片的类型： **&str**
- 将字符串切片作为函数参数，可以同时接收 String 和 &str 类型的参数

# struct

- 定义 struct

```rust
struct User {
  username:         String,
  email:            String,
  sign_in_count:    u64,
  active:           bool,   // 注意：最后一个字段也是以 “,” 结尾
}
```

- 实例化 struct

```rust
let user = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

- struct 更新语法

```rust
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

let user2 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  ..user1,
};
```

## Tuple struct

- 类似 tuple 的 struct，即：struct 整体有名，而字段没有名

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

## Unit-Like Struct

- 没有任何字段的结构体
- 适用于需要在某个类型上实现某个 trait，但在里面又没有想要存储的数据

## struct 所有权

```rust
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: bool,
}
```

- User 这个 struct 的字段是使用了 String，而不是 &str，所以
  - 该 struct 实力拥有其所有的数据
  - 只要 struct 实例是有效的，那么里面的字段数据也是有效的
- 当 struct 的字段是引用时，涉及到生命周期（后面讲解）
  - 生命周期保证只要 struct 实例是有效的，那么引用字段就是有效的 
  - 如果 struct 里面的字段是引用，而没有使用生命周期，程序就会报错

## 打印结构体

- 如果想要使用 **println!("{}", struct)** 来打印一个 struct 实例，必须实现 **std::fmt::Display** 函数，否则实现 **std::fmt::Debug** 函数
- 如果以上两个函数都没有实现，但却要调试信息，则可以在声明结构体时，在其上面添加 **#[derive(Debug)]** 后，后续则可以用 **{:?}** 或者 **{:#?}** 来打印出当前的结构体实例的结构