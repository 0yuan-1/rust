# 安装

- 官网：<https://www.rust-lang.org>
- 更新：```rustup update```
- 卸载：```rustup uninstall```
- rust 程序：
  - 程序后缀名：```rs```
  - 文件名规范：```hello_world.rs```

# 项目管理

- cargo：```cargo --version```
- 创建项目：```cargo new project_name```
- 构建项目：```cargo build```
  - 直接运行构建项目命令是 debug 版本，如果要 release 版本则需要添加```--release```
- 运行项目：```cargo run```
- 检查项目代码：```cargo check```

## Cargo.tomal

- cargo 项目的配置文件
- **在 Rust 中，一个包（项目）通常被称作 crate。如一个第三方的库，则称一个 crate**

```
# 用来配置包（项目）
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

# 包（项目）所使用的依赖
[dependencies]
```

# No.3 通用编程概念

## 3.1 变量与可变性

- Rust 中，变量是默认不可变的，如果一个变量的值后续要进行变化，则需要添加 “mut” 关键字

### 变量与常量

---

- 常量（constant）：常量在绑定值后也是不可变的，但与不可变的变量还是有区别：
  - 不可以使用 **mut**
  - 声明常量使用 **const** 关键字，它的类型必须标注
  - 常量可以在任何作用域进行声明
  - 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命名规范： Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如：
  - MAX_POINTS: ```const MAX_POINTS: u32 = 100_000;```

### Shadowing(隐藏)

---

- Rust 中，可以使用相同的名字声明新的变量，新的变量就会 shadow（隐藏）之前声明的同名变量，当后面的代码使用该变量时，就会使用新的，而不是旧的
- Shadow 和把变量标记为 **mut** 是不一样的
  - 如果不使用 **let** 关键字，那么重新给非 **mut** 的变量赋值会导致编译时错误
  - 而使用 **let** 声明的同名新变量，也是不可变的
  - 使用 **let**声明的同名新变量，它的类型可以与之前不同

## 3.2 数据类型

- 一般情况下，编译器都可以自动的推导出变量的数据类型，但当有多个数据类型符合一个变量时，则必须手动的设置

### 标量类型

---

- 一个标量类型代表一个单个值
- Rust 有四个主要的标量类型：
  - 整数类型
    - 无符号整数类型，以**u**开头
    - 有符号整数类型，以**i**开头
    - 一共有 5 种类型。8,16,32,64,128, **arch**.
    - **arch**：分别是“isize”和“usize”，**size** 的具体位数是由程序运行时的计算机架构决定的
    - 整数字面值：除了 byte 类型外，所有的数值字面值都允许使用类型后缀，例如：**57u8**：57是数值，u8是类型
  - 浮点类型
    - **f32**: 单精度
    - **f64**：双精度
  - 布尔类型
    - **true** 和 **false**
  - 字符类型
    - 占用 4 字节大小
    - 默认是 Unicode 标量值，而不是 ASCII 标量值

### 复合类型

---

- 将多个值存放到一个类型里
- Rust 提供两种基础的复合类型：元组（Tuple）、数组
  - 元组：
    - 可以将多个类型的值放到一个类型里
    - 长度固定
    - 创建 Tuple: ```let tup: (i32, f64, u8) = (500, 6.4, 1);```
    - 获取 Tuple 的元素值：```let (x, y, z) = tup; // 使用模式匹配来解构 Tuple，从而获取到元素的值```
    - 访问 Tuple 的元素：```println!("{}, {}, {}", tup.0, tup.1, tup.2); // 使用点标记法来访问元素的值```
  - 数组：
    - 创建数组：```let ary = [1,2,3,4,5,6];```
    - 数组的类型：```let ary2:[i32; 3] = [1,2,3]; // 显式的声明数组类型[type; len]```
    - 一般用于初始化数组： ```let ary3 =[0;3]; // 相当于 int ary[3] = {0};```
    - 访问数组的元素跟其他语言一样，但数组越界的处理上，Rust 是不允许的，具体表现为：**编译会通过**，**运行时会报错**

## 3.3 函数

- 函数使用 **fn** 关键字
- 函数必须声明每个参数的类型
- 函数的返回值类型必须在函数定义时，在 ‘->’ 后面声明。**函数的返回值不能被命名**

## 3.4 控制流

### if

---

- 在 rust 中，if 的 condition 中不需要添加‘()’
- 在 rust 中，if 的 condition 必须是布尔值
- 在 rust 中，if-else 的返回值类型必须是一样

### 循环

---

- loop：死循环，直到 break 条件生效
  - 如果 break 后面有跟表达式，则该表达式的值就是这个 loop 的返回值
- while
  - 跟其他语言的 while 循环基本一样
- for
  - 一般是用于遍历集合

#### Range

---

- 标准库提供的一个库，指定一个开始数字和结束数字， Range 可以生成它们之间的数字（[start_num .. end_num)）
- rev 方法可以反转 Range

# No.4 所有权

- 为了解决内存安全的问题，不再借助 GC 来进行管理（Java），或由程序员显示分配和释放内存（C、C++）
- 内存将有一个所有权系统来进行管理，其中包含一组编译器在编译时检查的规则，而因为检查是在编译期进行的，所以不会在运行期产生任何的开销
- 所有权解决的问题：
  - 跟踪代码的哪些部分正在使用 heap 的哪些数据
  - 最小化 heap 上的重复数据量
  - 清理 heap 上未使用的数据以避免空间不足
  - 所以所有权存在的原因是为了管理 heap 数据

## 4.1.1 所有权的规则

1. 每个值都有一个变量，该变量是该值的所有者
2. 每个值同时只能一个所有者
3. 当所有者超出作用域（scope）时，该值将被删除

### Drop 函数

---

- 当一个变量指向堆内存时，该变量离开作用域，rust 会自动调用 drop 函数

### 变量和数据交互的方式：移动（Move）

---

- 在 Rust 中，如果一个变量是指向栈内存，那么当其作为等号右值时，其值会被复制（拷贝）；当变量是指向堆内存，那么当作为右值时，其值会被移动到左值，该变量会变成无效。

### 变量和数据交互的方式：克隆（Clone）

---

- Rust 设计规则：Rust 不会自动创建数据的深拷贝
- clone 方法是对数据进行深拷贝

### 栈内存上的数据：复制（Copy）

---

- 当一个类型实现了 **Copy** 这个 trait， 那么旧的变量在赋值后仍然可用
- Rust 中规定：当一个类型或该类型的一部分实现了 drop 这个函数，那么 copy 则不能被实现
- 内置 copy 函数的类型：
  - 所有整型
  - bool
  - char
  - 所有浮点类型
  - Tuple 中，如果所有字段都是 Copy 的，那么其就可以 copy，否则不行。
    - (i32, i32) - 可以
    - (i32, String) - 不可以

## 4.1.2 所有权与函数

- 函数传参会与赋值一样均发生 **移动** 或 **复制** 的情况

### 返回值与作用域

---

- 返回值会发生所有权的转移

### 变量的所有权

---

- 把一个值赋值给其他变量时， 会发生移动
- 当一个包含 heap 数据的变量离开作用域时，它的值就会被 drop 函数 清理，除非数据的所有权移动到另一个变量上

## 4.2 引用与借用

### 引用

---

- Rust 为了避免变量的所有权的改变，而需要多次倒腾变量，提出了“引用”的特性，允许引用某些值而不取得所有权
- 使用引用， “&” 关键字

### 借用

---

- 当把引用作为函数参数时， 这个行为叫做借用
- 不能修改借用的东西， 因为引用默认是不可变的

### 可变引用

---

- **&mut** 可以将一个引用标示为可变引用
- **限制：在同一个作用域内，对某块数据，有且仅有一个可变的引用**，这样做的好处是为了防止数据竞争
  - 发生数据竞争的三种行为：
    1. 两个说多个指针同时访问同一个数据
    2. 至少有一个指针用于写入数据
    3. 没有使用任何机制来同步对数据的访问
- 可以通过创建新的作用域，来允许非同时的创建多个可变引用
- **限制：不可以同时拥有一个可变引用和不可变引用**

### 悬空引用（Dangling References）

---

- **一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用**
- 在 Rust 中，编译器则确保了不会发生这种情况

### 引用的规则

---

- 在任何给定的时刻，只能满足下列条件之一：
  - 一个可变的引用
  - 任意数量不可变的引用
- **引用必须一直有效**

## 4.3 切片（slice）

- Rust 中另一种不持有所有权的数据类型

### 字符串切片

---

- 指向字符串中的一部分引用， 当该字符串无效时，其切片也随之无效 
- 形式： ```&str[start_index..end_index]```
  - **start_index**: 切片起始位置的索引
  - **end_index**: 切片终止位置的下一个索引值
- 语法糖
  - 如果 start_index 从 0 开始，则可以不写
  - 如果 end_index 是字符串的长度，也可以不写
- **注意**
  - 字符串切片的范围索引必须发生在有效的 UTF-8 字符边界内
  - 当尝试从一个多字节的字符中创建字符串切片，程序会报错并退出
- 字符串切片的类型： **&str**
- 将字符串切片作为函数参数，可以同时接收 String 和 &str 类型的参数

# No.5 Struct

## 5.1 定义和实例化 struct

### 定义 struct

---

```rust
struct User {
  username:         String,
  email:            String,
  sign_in_count:    u64,
  active:           bool,   // 注意：最后一个字段也是以 “,” 结尾
}
```

### 实例化 struct

---

```
let user = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};
```

### struct 更新语法

---

```
let user1 = User {
    email: String::from("someone@example.com"),
    username: String::from("someusername123"),
    active: true,
    sign_in_count: 1,
};

let user2 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  ..user1,
};
```

### Tuple struct

---

- 类似 tuple 的 struct，即：struct 整体有名，而字段没有名

```
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

### Unit-Like Struct

---

- 没有任何字段的结构体
- 适用于需要在某个类型上实现某个 trait，但在里面又没有想要存储的数据

### struct 所有权

---

```rust
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: bool,
}
```

- User 这个 struct 的字段是使用了 String，而不是 &str，所以
  - 该 struct 实力拥有其所有的数据
  - 只要 struct 实例是有效的，那么里面的字段数据也是有效的
- 当 struct 的字段是引用时，涉及到生命周期（后面讲解）
  - 生命周期保证只要 struct 实例是有效的，那么引用字段就是有效的 
  - 如果 struct 里面的字段是引用，而没有使用生命周期，程序就会报错

### 打印结构体

---

- 如果想要使用 **println!("{}", struct)** 来打印一个 struct 实例，必须实现 **std::fmt::Display** 函数，否则实现 **std::fmt::Debug** 函数
- 如果以上两个函数都没有实现，但却要调试信息，则可以在声明结构体时，在其上面添加 **#[derive(Debug)]** 后，后续则可以用 **{:?}** 或者 **{:#?}** 来打印出当前的结构体实例的结构

## 5.2 struct 方法

- 与函数类似，不同之处：
  - 方法在 struct(或 enum、trait 对象)的上下文中定义
  - 第一个参数是 **self**

### 定义方法

---

- 在 **impl** 块里定义方法
- 方法的第一个参数可以是 **&self**，也可以是 **self**，或者是 **mut self** / **&mut self**，跟普通的参数一样

### 方法调用

---

- 在 Rust 中，并没有像 C/C++ 一样，有 “->” 和 “.” 的区别。Rust 只有 “.”，编译器会自动识别当前的方法调用，自动添加引用或解引用


### 关联函数

---

- 类似于 C++ 的静态方法
- 在 **impl**( implement ) 块里定义函数，但函数的第一个参数不再是 **self** 的，则是 **关联函数**
- 关联函数一般情况下，用于 struct 的构造器，例如： String::from() --- 就是一个关联函数

# No.6 枚举与模式匹配

## 6.1 定义枚举

- 使用关键字 **enum** 定义

```rust
enum IpAddrKind {
  V4,   // 枚举的变体
  V6,
}
```

- 将数据附加到枚举的变体中
  - 优点： 1. 不需要额外使用 struct，2. 每个变体可以拥有不同的类型以及关联的数据量

```rust
enum IpAddr {
  V4(u8, u8, u8, u8),
  V6(String),
}
```

### 定义枚举的方法

---

- 跟 struct 的一样，使用 **impl** 块进行定义

## 6.2 Option 枚举

- 定义于标准库中， 在 Prelude(预导入模块)中，描述了：某个值可能存在(某种类型)或不存在的情况，主要是为了解决 NULL 的情况
- **在 Rust 中，没有 Null 值存在**
- Option<T> 和 T 是不同的类型，不可以把 Option<T> 直接当成 T，要使用 Option<T> 中的 T，必须手动进行转化为 T
  - 调用 **expect()** 方法即可转化为 T
- 标准库中的定义：
  - 在使用 Option<T> 时，如果要编译器推导类型，则必须设置 T，否则编译器无法推导出变量的类型
 
```rust
enum Option<T> {
  Some(T),
  None,
}
```

## 6.3 控制刘运算符 - match

- 允许一个值与一系列模式进行匹配，并执行匹配的模式对应的代码
- 模式可以是字面值、变量名、通配符...
- 使用 match 匹配时，必须穷举所有的可能性，如果不想处理其中的某几种可能，则可以使用 “_” 来表示

### 绑定值的模式

---

- 匹配的分支可以绑定到被匹配对象的部分值，因此，可以从 enum 变体中提取值

## 6.4 if let

---

- 类似 match，但 if let 只关心一种匹配情况，而忽略其他情况


# No.7 Package, Crate, Module

- Package(包)：Cargo 的特性，构建，测试，共享 crate
- Crate(单元包)：一个模块树，它可产生一个 library 或可执行文件
- Module(模块)、use： 让你控制代码的组织、作用域、私有路径
- Path(路径)：为 struct、function 或 module 等项命名的方式

# No.8 常用的集合

- 集合：存放在堆内存上的数据结构，分别：Vector、String、HashMap

## 8.1 Vector

- Vec<T>，可以存放多个值，只能存放相同类型的数据，在内存中连续存放，类似与 array
- 创建 vector: **Vec::new()**
  - 使用初始值创建 Vec<T>: **vec!**
- 获取 vector 的值： 1. 索引，2. get()
  - 需要注意的是： 当使用索引获取时，如果越界了，程序就会崩溃。而使用 get() 函数则不会，会返回 None 值
- 对 vector 的所有权和借用规则都与默认的一样，例子
- 利用 enum 的变体可以存放多种数据类型的特性， 创建一个枚举类型的 vector 来存放多种数据类型，例子

## 8.2 String

### 创建 String 的方式：

---

- 使用 String::new 函数
- 使用 to_string() 方法
- 使用 String::form() 函数

### 更新 String：

---

- 使用 **push_str()** 方法，将一个 **字符串切片** 附加到 String
- 使用 **push()** 方法，将 **单个字符** 附加到 String

### 拼接 String：

---

- 使用 **+** 运算符拼接 String，需要注意的是： + 号左边的是 **字符串类型**，右边需要的是一个 **字符串切片**
  - 首先：加法运算在 Rust 中是使用了泛型，所以此处实际上是调用了类似： `fn add(self, s: &str) -> String` ，所以使用了 + 进行字符串拼接后，首个字符串的所有权会被转移
  - 第二个参数明明是字符串切片，但传递字符串引用却可以调用，是因为编译器在传参时，进行了解引用强制转换(deref coercion)
  - 字符串拼接运算符 + 左边只能是一个 String 类型，不能是 & 或 字符串切片类型，否则编译器会提示： **note: string concatenation requires an owned `String` on the left**
- 使用 **format!** 宏拼接 String
  - 使用 `format!()` 不会获取字符串的所有权，后续如果要使用其参数，是可以正常使用

### String 按索引方式访问

---

- 在 Rust 中，字符串是 utf-8 的形式保存
- Rust 的字符串不支持索引语法访问，因为没有实现 `Index<{integer}>` 这个 trait
 
### 内部封装 

---

- String 实际上是对 Vec<u8> 的包装
- 在 Rust 看来，字符串有三种形式：
  - 字节： Bytes
    - `for x in s.bytes()` --- 进行遍历
  - Unicode 标量值： Scalar Values
    - 对一个 String 类型进行 **len()** 的调用，其返回值是根据该字符串的 Unicode 标量值来计算的
    - `for x in s.chars()` --- 进行遍历
  - 字形簇： Grapheme Clusters
    - Rust 没有进行包装，需要使用第三方库进行遍历 

### 切割 String

---

- 可以使用 **[]** 和 一个范围来创建字符串的切片
- 当切割字符串时，必须严格按照字符串的字符边界进行切割，不然程序会 panic

## 8.3 HashMap

- HashMap 的数据存放在 Heap 上
- HashMap 是同构的，即：所有的 key 和 Value 必须是同一种类型


### 创建 HashMap 

---

- 创建空的 `HashMap::new()` 函数，添加数据 `insert()` 方法
- 使用 `collect()` 方法，在元素类型是 Tuple 的 Vector 上使用 collect 方法，则可以组建一个 HashMap，但要求 Tuple 有两个值，一个作为 Key，一个作为 value
  - 因为 collect 方法可以把数据整合成很多种集合类型，所以需要手动指定 **返回值的类型** 

### HashMap 和所有权

---

- 对于实现了 Copy trait 的类型，值会被复制到 HashMap 中
- 对于拥有所有权的值，值会被移动，所有权会转移给 HashMap，如果将值的引用插入到 HashMap，值本身不会移动，**但在 HashMap 有效的期间，被引用的值必须保持有效**

### 访问 HashMap 的值

---

- 例子

### 遍历 HashMap

---

- 例子

### 更新 HashMap 的值

---

- 例子

### Hash 函数 

---

- 默认情况下，HashMap 使用加密功能强大的 Hash 函数，可以抵抗拒绝服务（DoS）攻击，不是可用的最快的 Hash 算法，但具有更好安全性
- 可以制定不同的 hasher 来切换到另一个函数
  - hasher 是实现 BuildHasher trait 的类型 
  - （该内容需要自行找资料，视频没有详细讲解）

# No.9 错误处理

---

- Rust 会在编译阶段提示错误，要求程序员在该阶段进行处理，所以 Rust 较为可靠
- 错误分为：**可恢复** 和 **不可恢复**
  - 可恢复：例如文件未找到，可再次尝试
  - 不可恢复：bug，例如：数组访问越界等
- 大多数语言是使用异常机制进行处理，但 Rust 没有类似异常的机制，它提供了
  - 可恢复错误：`Result<T,E>`
  - 不可恢复错误： `panic!` 宏

## 9.1 不可恢复的错误与 panic!

- 当 panic! 执行的过程:
  - 程序会打印一个错误信息
  - 展开（unwind）、清理调用栈（Stack）
  - 退出程序
- 默认的情况下，当 panic 发生时，程序会展开调用栈（工作量巨大），Rust 会沿着调用栈进行回溯，清理掉每个遇到的函数中的数据
- 程序员可以通过 toml 文件，设置为 **立即终止调用栈**，即：不进行清理，直接停止程序（内存的清理工作将由 OS 进行）
  - 在 **Cargo.toml** 中适当的 **profile** 部分设置 `panic = 'abort'`

### 使用 panic! 产生回溯信息

---

- 通过设置环境变量 `RUST_BACKTRACE=1` 获取回溯信息
- 通过设置环境变量 `RUST_BACKTRACE=full` 获取更加详细的回溯信息

## 9.2 Result 与可恢复的错误

### Ruslt 枚举

---

```rust
enum Result<T, E> {
  Ok(T),
  Err(E),
}
```

- T: 操作成功的情况下，Ok 变体里返回的数据的类型
- E: 操作失败的情况下，Err 变体里返回的错误的类型
- 在 Result<T, E> 有很多方法都是可以接收闭包（closure）作为参数，使用这些方法可以让代码更加简洁
- `unwrap` 方法，其作用相当于一个 match 表达式的一个快捷方法，如果 Result 结果是 Ok 则返回 Ok 里面的值；如果 Result 结果是 Err 则调用 panic! 宏
  - 该方法的错误信息不能自定义 
- `expect` 方法与 `unwrap‵ 方法类似，但可指定错误信息

### 传播错误

---

- 当返回值是 Result<T, E> 时，就可以传播错误
- **?** 运算符是用于传播错误的一种快捷方式，它只能用于返回 Result 类型的函数
  - 如果 Result 是 Ok：Ok中的值就是表达式的结果，然后 继续执行程序
  - 如果 Result 是 Err：Err就是 **整个函数** 的返回值，就像使用了 return
  - ? 运算符会隐式的调用 from 函数，它所接收到的错误类型会被转化为当前函数返回类型所定义的错误类型
    - Trait std::convert::From 上的 from 函数，用于错误之间的转换 
    - 只有每个错误类型都实现s了转换为所返回的错误类型的 from 函数，才可以使用 ? 
- 如果要在 main 函数中使用 ？ 运算符，则需要修改 main 函数的返回值类型
  - `fn main() -> Result<(), Box<dyn Error>>` ，其中 **Box<dyn Error>** 需要使用 **use std::error::Error** 才可以，它是一个 trait 对象，可简单理解为“任何可能的错误类型”

## 9.3 什么时候应该使用 panic!

---

- 总体原则：**在定义一个可能失败的函数时，优先考虑返回 Result，否则就 panic!**
- [视频链接](https://www.bilibili.com/video/BV1hp4y1k7SV?p=42&spm_id_from=pageDriver&vd_source=acd7a7a6ca9b19c883482c0d52f771d5)

# No.10 泛型、Trait、生命周期

## 10.1 提取函数以消除重复代码

- 消除重复代码，最好的方式是将相同的逻辑，抽象成一个函数，后续只需要使用这个函数就可以完成该功能

## 10.2 泛型